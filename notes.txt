I’m Rendering Pages as PDFs in My Application  -->  Use Visualforce. Lightning Components don’t support rendering as PDF output yet.

ich muss das im Hinterkopf behalten sollten

bewährte Vorgehensweisen --> proven approches --> best practices

benutzerdefinierter Objekte --> custom object


Data import:
To analyse:
SF: Data Loader uses the SOAP API to process records. For faster processing, you can configure it to use the Bulk API instead. The Bulk API is optimized to load a large number of records simultaneously. It is faster than the SOAP API due to parallel processing and fewer network round-trips.
--> test it using the API practices and analyse the result how faster it can get.

1. it is recommended to test your data import witha  small test file or record file to confirm the field mapping and to make sure the data is imported correctly and no back end process is messing with the records.
2. to use the data import process, deactivate the workflow rules.
3. one can map the same field multiple times if required, for example address fields while importing can be mapped twice for contact as well as billing address.
4. unmapped fields are not imported
5. to import Multi select picklist, seperate the values by a semicolon in the import file.
6. Make sure the date format is aligned with your local salesforce settings.
7. vaölidation rules are fired when data is imported. If a a record fails, the particular record is not imported. One should consider deactivating the appropriate validation rules before running the import if the affect the records you are importing


Data Security:
The data security model is implemented at the user interface, but the impact of data security goes down till the API level. 


Lightning Components
--------------------
1. Salesforce requires My Domain as a security measure to help prevent malicious attacks—just in case a security hole lies hidden deep within a third-party or custom component.
2. A lightning component needs to implements="force:appHostable", for being hostable in the application.
3. Visualforce was created before mobile apps on phones became a thing. While you can develop mobile apps with Visualforce, none of the built-in components are mobile-savvy. Which means you write more code. Lightning Components, on the other hand, is specifically optimized to perform well on mobile devices.
4.Other Web development framworks AngularJS, React, or Ember.
To use these frameworks : We recommend using them with Visualforce, using what we call a container page, and packaging your chosen framework and app code into static resources. Using an empty container page has Visualforce get out of your way, and lets you use the full capabilities of your chosen framework.
5. Another thing to consider: general-purpose frameworks such as AngularJS are designed to be agnostic about the platform they run on top of, in particular data services. Lightning Components, on the other hand, is designed to connect natively with services provided by Salesforce and the Force.com platform. Which do you think is going to help you build apps faster?
6. Resources in a bundle are auto-wired together via a naming scheme for each resource type. Auto-wiring just means that a component definition can reference its controller, helper, etc., and those resources can reference the component definition. They are hooked up to each other (mostly) automatically.
7. You can’t add apps to Lightning Experience or the Salesforce app—you can only add components. After the last unit this might sound weird; what exactly do you add to the App Launcher, if not an app? What you add to App Launcher is a Salesforce app, which wraps up a Lightning component, something defined in a <aura:component>. A Lightning Components app—that is, something defined in a <aura:application> —can’t be used to create Salesforce apps. A bit weird, but there it is.
So, what’s an app good for? Why would you ever use one? We answered that question earlier. You publish functionality built with Lightning Components in containers. Lightning Components apps are one kind of container for our Lightning components.

Once again being practical, this usually means that you build all of your “app” functionality inside a top-level component. Then at the end, you stick that one component in a container—maybe a Lightning Components app, maybe the Salesforce app, maybe something else. If you use a my.app, the container can set up services for your main component, but otherwise it’s just there to host the component.
8. 




1. An expression is basically a formula, or a calculation, which you place within expression delimiters (“{!” and “}”). So, expressions look like the following:
2. You can’t use JavaScript in expressions in Lightning Components markup.
3. A controller is basically a collection of code that defines your app’s behavior when “things happen,” whereby “things” we mean user input, timer and other events, data updates, and so on. 
4. In a word, no. There are similarities, to be sure, but it would be more correct to say that Lightning Components is View-Controller-Controller-Model, or perhaps View-Controller-Controller-Database. Why is “controller” doubled up in that pattern name? Because when interacting with Salesforce, your components will have a server-side controller in addition to the client-side controller we’ve worked with in this unit. This dual controller design is the key difference between Lightning Components and MVC.
5. <lightning:input> is the Swiss army knife for input fields that’s infused with the goodness of SLDS styling. Use it whenever you find yourself reaching for the <ui:input> component variety like <ui:inputText>, <ui:inputNumber>, and others. Components in the ui namespace don’t come with SLDS styling and are considered to be legacy components.
6. Next, there’s an aura:id attribute set on each tag. What’s that for? It sets a (locally) unique ID on each tag it’s added to, and that ID is how you’ll read values out of the form fields. The fields all share the same ID in this example so that we can access them as an array for field validation. We’ll look at how to do that very shortly.
7. aria-* : The Accessible Rich Internet Applications specification 
8. when your controller needs a way to get to a child component, first set an aura:id on that component in markup, and then use component.find(theId) to get a reference to the component at runtime.
9. Helper function:
   --A component’s helper is the appropriate place to put code to be shared between several different action handlers.
   --A component’s helper is a great place to put complex processing details, so that the logic of your action handlers remains clear and streamlined.
   --Helper functions can have any function signature. That is, they’re not constrained the way that action handlers in the controller are. (Why is this? Because you are calling the helper function directly from your code. By contrast, the framework calls action handlers via the framework runtime.) It’s a convention and recommended practice to always provide the component as the first parameter to helper functions.
10. The static keyword. All @AuraEnabled controller methods must be static methods, and either public or global scope.
11. in controller.js the component.get("c.getdata"),  c. represents the remote Apex controller.
12. c. Identifier, three places in a component
     c. | Component markup | Client-side controller
     c. | Controller code  | Server-side controller
     c: | Markup | Default namespace
     we have c the client-side controller, c the default namespace, and c the server-side controller, all in Lightning Components
13. $A.enqueueAction(action).
    --It queues up the server request.
    --As far as your controller action is concerned, that’s the end of it.
    --You’re not guaranteed when, or if, you’ll hear back.
14.  The first issue is case sensitivity, and this boils down to Apex and Salesforce in general are case-insensitive, but JavaScript is case-sensitive. That is, “Name” and “name” are the same in Apex, but different in JavaScript.
15. There are two principal ways to interact with or affect another component. 
    --The first way is one we’ve seen and done quite a bit of already: setting attributes on the component’s tag. A component’s public attributes constitute one part of its API.
    --The second way to interact with a component is through events. 
    :-Like attributes, components declare the events they send out, and the events they can handle. Like attributes, these public events constitute a part of the component’s public API. 
16. With attributes:  you create a direct relationship between those two components. They are linked, and while they’re using public APIs to remain independent of each other, they’re still coupled.
    --Events are different. Components don’t send events to another component. That’s not how events work. Components broadcast events of a particular type. If there’s a component that responds to that type of event, and if that component “hears” your event, then it will act on it.
17. There are two types of events, component and application. Here we’re using a component event, because we want an ancestor component to catch and handle the event. An ancestor is a component “above” this one in the component hierarchy. If we wanted a “general broadcast” kind of event, where any component could receive it, we’d use an application event instead.
Different attribute types.
18. 
--------------------------
Primitives data types, such as Boolean, Date, DateTime, Decimal, Double, Integer, Long, or String. The usual suspects in any programming language.
Standard and custom Salesforce objects, such as Account or MyCustomObject__c.
Collections, such as List, Map, and Set.
Custom Apex classes.
Framework-specific types, such as Aura.Component, or Aura.Component[].

Lightning Components:
{!} --- expression
{!v.message}, {!v.account.Id} ---- v is value provider (message is the name of the attribute). Value providers are a way to group, encapsulate and access related data.
{!c.handleClick} -- is also a value provider for the component's client side controller. handleClick is the function defined in that controller. So, {!c.handleClick} is a reference to an action handler in the components controller.


